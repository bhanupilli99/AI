class State:
    def __init__(self, missionaries, cannibals, boat, parent=None):
        self.missionaries = missionaries
        self.cannibals = cannibals
        self.boat = boat
        self.parent = parent

    def is_valid(self):
        if self.missionaries < 0 or self.cannibals < 0:
            return False
        if self.missionaries < self.cannibals and self.missionaries > 0:
            return False
        if 3 - self.missionaries < 3 - self.cannibals and 3 - self.missionaries > 0:
            return False
        return True

    def is_goal(self):
        return self.missionaries == 0 and self.cannibals == 0

    def __eq__(self, other):
        return (
            self.missionaries == other.missionaries
            and self.cannibals == other.cannibals
            and self.boat == other.boat
        )

    def __hash__(self):
        return hash((self.missionaries, self.cannibals, self.boat))


def generate_successors(current_state):
    successors = []
    moves = [(1, 0), (2, 0), (0, 1), (0, 2), (1, 1)]
    for move in moves:
        if current_state.boat == 1:
            new_state = State(
                current_state.missionaries - move[0],
                current_state.cannibals - move[1],
                0,
                current_state,
            )
        else:
            new_state = State(
                current_state.missionaries + move[0],
                current_state.cannibals + move[1],
                1,
                current_state,
            )
        if new_state.is_valid():
            successors.append(new_state)
    return successors


def breadth_first_search():
    initial_state = State(3, 3, 1)
    if initial_state.is_goal():
        return [initial_state]

    frontier = [initial_state]
    explored = set()

    while frontier:
        state = frontier.pop(0)

        if state.is_goal():
            solution = []
            while state:
                solution.insert(0, state)
                state = state.parent
            return solution

        explored.add(state)

        successors = generate_successors(state)
        for child in successors:
            if child not in explored and child not in frontier:
                frontier.append(child)

    return None


def print_solution(solution):
    for i, state in enumerate(solution):
        print(
            f"Step {i + 1}: {state.missionaries} missionaries, {state.cannibals} cannibals, boat on {'left' if state.boat == 0 else 'right'} side."
        )


if __name__ == "__main__":
    solution = breadth_first_search()
    if solution:
        print_solution(solution)
    else:
        print("No solution found.")
